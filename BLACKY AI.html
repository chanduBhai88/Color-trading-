<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fixed Big/Small Predictor</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
      color: #ffffff;
      text-align: center;
      padding: 20px;
      min-height: 100vh;
      margin: 0;
    }
    h1 { color: #00d4ff; margin-bottom: 30px; text-shadow: 0px 0px 20px #00d4ff; font-size: 2.2em; font-weight: 300; }
    .controls { margin: 30px 0; }
    .btn { padding: 15px 30px; margin: 8px; border: none; cursor: pointer; font-weight: bold; border-radius: 25px; transition: all 0.3s ease; font-size: 18px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
    .big-btn { background: linear-gradient(45deg, #ff416c, #ff4b2b); color: white; }
    .small-btn { background: linear-gradient(45deg, #4facfe, #00f2fe); color: white; }
    .clear-btn { background: linear-gradient(45deg, #667eea, #764ba2); color: white; }
    .btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 8px 25px rgba(0,0,0,0.4); }
    .stats-container { display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
    .stat-card { background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 15px 25px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2); }
    .history { margin: 20px auto; max-width: 600px; background: rgba(255,255,255,0.05); backdrop-filter: blur(15px); padding: 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); }
    .recent-results { display: flex; justify-content: center; gap: 8px; margin: 15px 0; flex-wrap: wrap; }
    .result-dot { width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); position: relative; }
    .dot-big { background: linear-gradient(45deg, #ff416c, #ff4b2b); }
    .dot-small { background: linear-gradient(45deg, #4facfe, #00f2fe); }
    .correct-prediction { border: 3px solid #00ff00; animation: glow 1s ease-in-out; }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 5px #00ff00; } 50% { box-shadow: 0 0 20px #00ff00; } }
    .prediction-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; max-width: 1200px; margin: 30px auto; }
    .card { background: rgba(255,255,255,0.08); backdrop-filter: blur(20px); padding: 25px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.15); transition: all 0.3s ease; position: relative; overflow: hidden; }
    .card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #00d4ff, #ff416c, #4facfe); }
    .card:hover { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,212,255,0.3); }
    .card.correct-prediction { border: 2px solid #00ff00; box-shadow: 0 0 20px rgba(0,255,0,0.3); }
    .big { color: #ff416c; font-weight: bold; }
    .small { color: #4facfe; font-weight: bold; }
    .accuracy { font-size: 0.9em; opacity: 0.8; margin-top: 10px; }
    .confidence-bar { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; margin: 10px 0; overflow: hidden; }
    .confidence-fill { height: 100%; background: linear-gradient(90deg, #00d4ff, #4facfe); border-radius: 10px; transition: width 0.5s ease; }
    .debug-info { margin: 20px auto; max-width: 800px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; font-size: 0.9em; text-align: left; }
  </style>
</head>
<body>
  <h1>üéØ Fixed Big/Small Predictor</h1>

  <div class="controls">
    <button class="btn big-btn" onclick="addResult('Big')">üî¥ Big</button>
    <button class="btn small-btn" onclick="addResult('Small')">üîµ Small</button>
    <button class="btn clear-btn" onclick="clearHistory()">üóëÔ∏è Reset</button>
  </div>

  <div class="stats-container">
    <div class="stat-card"><div>Total: <span id="totalCount">0</span></div></div>
    <div class="stat-card"><div>Big: <span id="bigCount" class="big">0</span></div></div>
    <div class="stat-card"><div>Small: <span id="smallCount" class="small">0</span></div></div>
    <div class="stat-card"><div>Best Algorithm: <span id="bestAlgo">None</span></div></div>
  </div>

  <div class="history">
    <h3>Recent Results (Last 20)</h3>
    <div class="recent-results" id="recentResults"><p style="opacity: 0.6;">No results yet...</p></div>
  </div>

  <div class="prediction-grid">
    <div class="card" id="prediction1"></div>
    <div class="card" id="prediction2"></div>
    <div class="card" id="prediction3"></div>
    <div class="card" id="prediction4"></div>
  </div>

  <div class="debug-info" id="debugInfo" style="display: none;">
    <h4>Debug Information:</h4>
    <div id="debugContent"></div>
  </div>

  <script>
    let history = [];
    let predictionHistory = [];
    let algorithms = ['Frequency Analysis', 'Anti-Streak', 'Pattern Recognition', 'AI Fusion'];

    function addResult(result) {
      history.unshift(result);
      if (history.length > 100) history.pop();
      if (predictionHistory.length > 0) {
        let lastPredictions = predictionHistory[predictionHistory.length - 1];
        lastPredictions.actual = result;
        lastPredictions.correct = lastPredictions.predictions.map(pred => pred === result);
        lastPredictions.correct.forEach((isCorrect, index) => {
          if (isCorrect) {
            document.getElementById(`prediction${index + 1}`).classList.add('correct-prediction');
            setTimeout(() => { document.getElementById(`prediction${index + 1}`).classList.remove('correct-prediction'); }, 2000);
          }
        });
      }
      updateStats();
      updateRecentResults();
      makePredictions();
      updateDebugInfo();
    }

    function clearHistory() {
      history = [];
      predictionHistory = [];
      updateStats();
      updateRecentResults();
      clearPredictions();
      document.getElementById('debugInfo').style.display = 'none';
    }

    function updateStats() {
      let total = history.length;
      let bigCount = history.filter(r => r === "Big").length;
      let smallCount = total - bigCount;
      document.getElementById("totalCount").textContent = total;
      document.getElementById("bigCount").textContent = bigCount;
      document.getElementById("smallCount").textContent = smallCount;
      if (predictionHistory.length > 5) {
        let accuracies = [0, 1, 2, 3].map(algoIndex => {
          let correct = 0, total = 0;
          predictionHistory.forEach(pred => {
            if (pred.actual && pred.correct) { total++; if (pred.correct[algoIndex]) correct++; }
          });
          return total > 0 ? (correct / total) * 100 : 0;
        });
        let bestIndex = accuracies.indexOf(Math.max(...accuracies));
        document.getElementById("bestAlgo").textContent = algorithms[bestIndex] + ` (${accuracies[bestIndex].toFixed(1)}%)`;
      } else {
        document.getElementById("bestAlgo").textContent = "Need more data";
      }
    }

    function updateRecentResults() {
      let container = document.getElementById("recentResults");
      if (history.length === 0) { container.innerHTML = '<p style="opacity: 0.6;">No results yet...</p>'; return; }
      let recent = history.slice(0, 20);
      container.innerHTML = recent.map(result => `<div class="result-dot dot-${result.toLowerCase()}">${result[0]}</div>`).join('');
    }

    function clearPredictions() {
      for (let i = 1; i <= 4; i++) {
        document.getElementById("prediction" + i).innerHTML = `<h3>${['üßÆ','‚ö°','üîç','ü§ñ'][i-1]} ${algorithms[i-1]}</h3><p style="opacity: 0.6;">Waiting for data...</p>`;
      }
    }

    function makePredictions() {
      if (history.length < 2) { clearPredictions(); return; }

      let predictions = [], confidences = [], explanations = [];

      // Algorithm 1: Frequency
      let recentWindow = Math.min(10, history.length);
      let recentHistory = history.slice(0, recentWindow);
      let bigCount = recentHistory.filter(r => r === "Big").length;
      let smallCount = recentWindow - bigCount;
      let ratio = bigCount / recentWindow;
      let freq_pred = ratio > 0.6 ? "Small" : ratio < 0.4 ? "Big" : (Math.random() > 0.5 ? "Big" : "Small");
      let freq_conf = Math.abs(ratio - 0.5) * 200;
      if (freq_conf < 55) freq_conf = 55 + Math.random() * 15;
      predictions.push(freq_pred);
      confidences.push(freq_conf);
      explanations.push(`Recent ${recentWindow}: ${bigCount}B/${smallCount}S (${(ratio*100).toFixed(0)}% Big)`);

      // Algorithm 2: Anti-Streak
      let streakLength = 1;
      for (let i = 1; i < history.length && history[i] === history[0]; i++) streakLength++;
      let streak_pred = streakLength >= 3 ? (history[0] === "Big" ? "Small" : "Big") : history[0];
      let streak_conf = Math.min(90, streakLength * 20 + 40);
      predictions.push(streak_pred);
      confidences.push(streak_conf);
      explanations.push(`Current streak: ${streakLength} ${history[0]}'s`);

      // Algorithm 3: Improved Pattern Detection
      let pattern_pred = "Big", pattern_conf = 50, pattern_explanation = "No clear pattern detected";
      if (history.length >= 3) {
        let streakLen = 1;
        for (let i = 1; i < history.length && history[i] === history[0]; i++) streakLen++;
        if (streakLen >= 3) {
          pattern_pred = history[0] === "Big" ? "Small" : "Big";
          pattern_conf = Math.min(90, streakLen * 15 + 40);
          pattern_explanation = `Streak of ${streakLen} ${history[0]}'s ‚Üí predicting opposite`;
        }
        if (history.length >= 4) {
          let last4 = history.slice(0,4);
          if (last4[0] === last4[1] && last4[2] === last4[3] && last4[0] !== last4[2]) {
            pattern_pred = last4[0]; pattern_conf = 75; pattern_explanation = "Detected 2-2 repeating block";
          }
          if (history.length >= 6) {
            let last6 = history.slice(0,6);
            if (last6[0] === last6[1] && last6[2] === last6[3] && last6[4] === last6[5]) {
              pattern_pred = last6[0] === "Big" ? "Small" : "Big";
              pattern_conf = 80; pattern_explanation = "3-block cycle detected";
            }
          }
        }
        if (history.length >= 8) {
          let last4 = history.slice(0,4).join("");
          let prev4 = history.slice(4,8).join("");
          if (last4 === prev4) {
            pattern_pred = history[0] === "Big" ? "Small" : "Big";
            pattern_conf = 85; pattern_explanation = "Mirror pattern found";
          }
        }
      }
      predictions.push(pattern_pred);
      confidences.push(pattern_conf);
      explanations.push(pattern_explanation);

      // Algorithm 4: Ensemble
      let weights = { freq: 0.3, streak: 0.4, pattern: 0.3 };
      let bigScore = 0;
      bigScore += (predictions[0] === "Big" ? weights.freq : -weights.freq);
      bigScore += (predictions[1] === "Big" ? weights.streak : -weights.streak);
      bigScore += (predictions[2] === "Big" ? weights.pattern : -weights.pattern);
      let final_pred = bigScore > 0 ? "Big" : "Small";
      let final_conf = Math.min(95, Math.abs(bigScore) * 100 + 60);
      predictions.push(final_pred);
      confidences.push(final_conf);
      explanations.push(`Weighted score: ${bigScore.toFixed(2)} (${predictions.join(', ')})`);

      predictionHistory.push({ timestamp: Date.now(), predictions:[...predictions], confidences:[...confidences], explanations:[...explanations], actual:null, correct:null });

      let accuracies = [0,1,2,3].map(algoIndex=>{
        let correct=0,total=0;
        predictionHistory.forEach(pred=>{ if(pred.actual && pred.correct){ total++; if(pred.correct[algoIndex]) correct++; } });
        return total>0?(correct/total)*100:0;
      });

      predictions.forEach((pred,index)=>{
        let accuracy = accuracies[index];
        let total_predictions = predictionHistory.filter(p=>p.actual).length;
        document.getElementById(`prediction${index+1}`).innerHTML = `
          <h3>${['üßÆ','‚ö°','üîç','ü§ñ'][index]} ${algorithms[index]}</h3>
          <p>Prediction: <span class="${pred.toLowerCase()}">${pred}</span></p>
          <div class="confidence-bar"><div class="confidence-fill" style="width:${confidences[index]}%"></div></div>
          <p>Confidence: ${confidences[index].toFixed(0)}%</p>
          <div class="accuracy">Accuracy: ${accuracy.toFixed(1)}% (${Math.floor(accuracy*total_predictions/100)}/${total_predictions})</div>
          <div style="font-size:0.8em;margin-top:8px;opacity:0.7;">${explanations[index]}</div>`;
      });

      document.getElementById('debugInfo').style.display = 'block';
    }

    function updateDebugInfo() {
      if (predictionHistory.length === 0) return;
      let debug = document.getElementById('debugContent');
      let latest = predictionHistory[predictionHistory.length - 1];
      debug.innerHTML = `
        <p><strong>Last Prediction Round:</strong></p>
        <p>Predictions: ${latest.predictions.join(', ')}</p>
        <p>Actual Result: ${latest.actual || 'Waiting...'}</p>
        <p>Correct: ${latest.correct ? latest.correct.map(c => c ? '‚úì' : '‚úó').join(', ') : 'Waiting...'}</p>
        <p><strong>Total Predictions Made:</strong> ${predictionHistory.filter(p => p.actual).length}</p>`;
    }

    clearPredictions();
  </script>
</body>
</html>